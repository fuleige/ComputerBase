# C++ 中原子变量内存序使用

## 1. 基本概念和问题引入

### 1.1 基本概念

- 内存序就是CPU访问内存的顺序,它其实取决于编译器生成的指令顺序和CPU执行时的指令顺序.
- 程序执行即有指令重排序现象, 为了提高性能, 编译器可能会对指令进行重排序
    - 重排序为什么能提高性能, 举个很简单例子, 至少可以将访问某块相近的内存一些指令放在一起, 充分利用cache提高速度(本来这块内存本来加入到cache中的,随后随着访问移除cache了,然后后面有指令访问这块内存时,那不还得重新从内存读到cache啊)
    - 当然实际上编译器或者CPU对指令的优化为有着更加复杂的规则, 但不可否认, 指令并非完整按照编程的顺序执行

### 1.2 问题引入
以下是一个经典用于描述这个现象的示例
```C++
// 全局变量
int a = 0;
int b = 0;
bool init = false; 

// 线程1 (做一些初始化工作,然后更改标记状态)
a = 16;
b = 32;
init = true; // 由于存在指令重排的情况,可以先于前面的指令执行

// 线程2 
while(!init);
assert(a>10); // 仍然可能触发断言
```

- 指令之间的依赖关系

```C++
int x = 10;
int y = x + 5; // y对x有依赖关系,y执行这个操作不可能先于 x=10执行
int z = 3;     // 对前两条没有依赖关系, 可能早于前两条指令执行
```
- 对于没有依赖关系的指令,指令可能会重排序,这种行为应该是不可预期的
- 毕竟没有依赖关系的,怎么执行都不会影响程序最终的正确性
- 但是是如果是多个线程之间, 其他线程确实依赖于你的指令顺序性, 那么可能会发生非预期的结果

## 2. 原子变量的内存序

